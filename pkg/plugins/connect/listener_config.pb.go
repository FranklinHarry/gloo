// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: listener_config.proto

/*
Package connect is a generated protocol buffer package.

It is generated from these files:
	listener_config.proto

It has these top-level messages:
	ListenerConfig
	InboundListenerConfig
	OutboundListenerConfig
	TcpProxyConfig
*/
package connect

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_config_filter_network_client_certificate_restriction_v2 "github.com/solo-io/gloo-enterprise/pkg/plugins/connect"
import _ "gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// the listenerConfig must be either an InboundListener or an OutboundListener
type ListenerConfig struct {
	// Types that are valid to be assigned to Config:
	//	*ListenerConfig_Inbound
	//	*ListenerConfig_Outbound
	Config isListenerConfig_Config `protobuf_oneof:"config"`
}

func (m *ListenerConfig) Reset()                    { *m = ListenerConfig{} }
func (m *ListenerConfig) String() string            { return proto.CompactTextString(m) }
func (*ListenerConfig) ProtoMessage()               {}
func (*ListenerConfig) Descriptor() ([]byte, []int) { return fileDescriptorListenerConfig, []int{0} }

type isListenerConfig_Config interface {
	isListenerConfig_Config()
	Equal(interface{}) bool
}

type ListenerConfig_Inbound struct {
	Inbound *InboundListenerConfig `protobuf:"bytes,1,opt,name=inbound,oneof"`
}
type ListenerConfig_Outbound struct {
	Outbound *OutboundListenerConfig `protobuf:"bytes,2,opt,name=outbound,oneof"`
}

func (*ListenerConfig_Inbound) isListenerConfig_Config()  {}
func (*ListenerConfig_Outbound) isListenerConfig_Config() {}

func (m *ListenerConfig) GetConfig() isListenerConfig_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ListenerConfig) GetInbound() *InboundListenerConfig {
	if x, ok := m.GetConfig().(*ListenerConfig_Inbound); ok {
		return x.Inbound
	}
	return nil
}

func (m *ListenerConfig) GetOutbound() *OutboundListenerConfig {
	if x, ok := m.GetConfig().(*ListenerConfig_Outbound); ok {
		return x.Outbound
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListenerConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListenerConfig_OneofMarshaler, _ListenerConfig_OneofUnmarshaler, _ListenerConfig_OneofSizer, []interface{}{
		(*ListenerConfig_Inbound)(nil),
		(*ListenerConfig_Outbound)(nil),
	}
}

func _ListenerConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListenerConfig)
	// config
	switch x := m.Config.(type) {
	case *ListenerConfig_Inbound:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Inbound); err != nil {
			return err
		}
	case *ListenerConfig_Outbound:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Outbound); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ListenerConfig.Config has unexpected type %T", x)
	}
	return nil
}

func _ListenerConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListenerConfig)
	switch tag {
	case 1: // config.inbound
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InboundListenerConfig)
		err := b.DecodeMessage(msg)
		m.Config = &ListenerConfig_Inbound{msg}
		return true, err
	case 2: // config.outbound
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OutboundListenerConfig)
		err := b.DecodeMessage(msg)
		m.Config = &ListenerConfig_Outbound{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ListenerConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListenerConfig)
	// config
	switch x := m.Config.(type) {
	case *ListenerConfig_Inbound:
		s := proto.Size(x.Inbound)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ListenerConfig_Outbound:
		s := proto.Size(x.Outbound)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// configuration for the inbound listener
// this listener does authentication and connects
// clients to the local service
type InboundListenerConfig struct {
	// configuration for tls-based auth filter
	AuthConfig *envoy_config_filter_network_client_certificate_restriction_v2.ClientCertificateRestriction `protobuf:"bytes,1,opt,name=auth_config,json=authConfig" json:"auth_config,omitempty"`
	// the name of the local upstream being proxied
	// the service being proxied must be reachable by Envoy via 'localhost'
	LocalUpstreamName string `protobuf:"bytes,2,opt,name=local_upstream_name,json=localUpstreamName,proto3" json:"local_upstream_name,omitempty"`
	// the port the local service is listening on
	LocalServicePort uint32 `protobuf:"varint,3,opt,name=local_service_port,json=localServicePort,proto3" json:"local_service_port,omitempty"`
}

func (m *InboundListenerConfig) Reset()         { *m = InboundListenerConfig{} }
func (m *InboundListenerConfig) String() string { return proto.CompactTextString(m) }
func (*InboundListenerConfig) ProtoMessage()    {}
func (*InboundListenerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorListenerConfig, []int{1}
}

func (m *InboundListenerConfig) GetAuthConfig() *envoy_config_filter_network_client_certificate_restriction_v2.ClientCertificateRestriction {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *InboundListenerConfig) GetLocalUpstreamName() string {
	if m != nil {
		return m.LocalUpstreamName
	}
	return ""
}

func (m *InboundListenerConfig) GetLocalServicePort() uint32 {
	if m != nil {
		return m.LocalServicePort
	}
	return 0
}

// The configuration for the outbound listeners which serve as "tcp routes"
type OutboundListenerConfig struct {
	// configuration for the tcp proxy filter
	ProxyConfig *TcpProxyConfig `protobuf:"bytes,1,opt,name=proxy_config,json=proxyConfig" json:"proxy_config,omitempty"`
}

func (m *OutboundListenerConfig) Reset()         { *m = OutboundListenerConfig{} }
func (m *OutboundListenerConfig) String() string { return proto.CompactTextString(m) }
func (*OutboundListenerConfig) ProtoMessage()    {}
func (*OutboundListenerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorListenerConfig, []int{2}
}

func (m *OutboundListenerConfig) GetProxyConfig() *TcpProxyConfig {
	if m != nil {
		return m.ProxyConfig
	}
	return nil
}

type TcpProxyConfig struct {
	// The name of the destination upstream for the listener
	DestinationUpstream string `protobuf:"bytes,1,opt,name=destination_upstream,json=destinationUpstream,proto3" json:"destination_upstream,omitempty"`
}

func (m *TcpProxyConfig) Reset()                    { *m = TcpProxyConfig{} }
func (m *TcpProxyConfig) String() string            { return proto.CompactTextString(m) }
func (*TcpProxyConfig) ProtoMessage()               {}
func (*TcpProxyConfig) Descriptor() ([]byte, []int) { return fileDescriptorListenerConfig, []int{3} }

func (m *TcpProxyConfig) GetDestinationUpstream() string {
	if m != nil {
		return m.DestinationUpstream
	}
	return ""
}

func init() {
	proto.RegisterType((*ListenerConfig)(nil), "gloo.api.v1.ListenerConfig")
	proto.RegisterType((*InboundListenerConfig)(nil), "gloo.api.v1.InboundListenerConfig")
	proto.RegisterType((*OutboundListenerConfig)(nil), "gloo.api.v1.OutboundListenerConfig")
	proto.RegisterType((*TcpProxyConfig)(nil), "gloo.api.v1.TcpProxyConfig")
}
func (this *ListenerConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListenerConfig)
	if !ok {
		that2, ok := that.(ListenerConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Config == nil {
		if this.Config != nil {
			return false
		}
	} else if this.Config == nil {
		return false
	} else if !this.Config.Equal(that1.Config) {
		return false
	}
	return true
}
func (this *ListenerConfig_Inbound) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListenerConfig_Inbound)
	if !ok {
		that2, ok := that.(ListenerConfig_Inbound)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Inbound.Equal(that1.Inbound) {
		return false
	}
	return true
}
func (this *ListenerConfig_Outbound) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListenerConfig_Outbound)
	if !ok {
		that2, ok := that.(ListenerConfig_Outbound)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Outbound.Equal(that1.Outbound) {
		return false
	}
	return true
}
func (this *InboundListenerConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InboundListenerConfig)
	if !ok {
		that2, ok := that.(InboundListenerConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AuthConfig.Equal(that1.AuthConfig) {
		return false
	}
	if this.LocalUpstreamName != that1.LocalUpstreamName {
		return false
	}
	if this.LocalServicePort != that1.LocalServicePort {
		return false
	}
	return true
}
func (this *OutboundListenerConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OutboundListenerConfig)
	if !ok {
		that2, ok := that.(OutboundListenerConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProxyConfig.Equal(that1.ProxyConfig) {
		return false
	}
	return true
}
func (this *TcpProxyConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TcpProxyConfig)
	if !ok {
		that2, ok := that.(TcpProxyConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DestinationUpstream != that1.DestinationUpstream {
		return false
	}
	return true
}

func init() { proto.RegisterFile("listener_config.proto", fileDescriptorListenerConfig) }

var fileDescriptorListenerConfig = []byte{
	// 436 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x52, 0xc1, 0x6a, 0x14, 0x41,
	0x10, 0x75, 0x14, 0x62, 0xd2, 0xab, 0x41, 0x27, 0x89, 0x84, 0x08, 0x12, 0xd6, 0x4b, 0x0e, 0xa6,
	0x9b, 0xac, 0xe0, 0x49, 0x02, 0x66, 0x2f, 0x0a, 0xa2, 0x61, 0x54, 0x10, 0x3d, 0x0c, 0xbd, 0x9d,
	0xda, 0x49, 0x91, 0xde, 0xae, 0xa6, 0xa7, 0x66, 0x34, 0xe0, 0xaf, 0x78, 0xf7, 0xbb, 0xfc, 0x05,
	0x7f, 0x40, 0xa6, 0x7b, 0x92, 0xcd, 0x90, 0x40, 0x6e, 0x35, 0xf3, 0x5e, 0xbd, 0x57, 0xef, 0xd1,
	0x62, 0xcb, 0x62, 0xcd, 0xe0, 0x20, 0x94, 0x86, 0xdc, 0x1c, 0x2b, 0xe9, 0x03, 0x31, 0xe5, 0xa3,
	0xca, 0x12, 0x49, 0xed, 0x51, 0xb6, 0x07, 0x3b, 0x16, 0x5c, 0x4b, 0xe7, 0x4a, 0x7b, 0x54, 0x69,
	0x4a, 0x54, 0x35, 0x47, 0xcb, 0x10, 0x94, 0x03, 0xfe, 0x41, 0xe1, 0x4c, 0x19, 0x8b, 0xe0, 0xb8,
	0x34, 0x10, 0x18, 0xe7, 0x68, 0x34, 0x43, 0x19, 0xa0, 0xe6, 0x80, 0x86, 0x91, 0x9c, 0x6a, 0x27,
	0xb7, 0x30, 0x92, 0xf5, 0xce, 0x66, 0x45, 0x15, 0xc5, 0x51, 0x75, 0x53, 0xfa, 0x3b, 0xfe, 0x9d,
	0x89, 0xf5, 0xf7, 0xfd, 0xa9, 0xd3, 0x68, 0x9f, 0x1f, 0x8a, 0xfb, 0xe8, 0x66, 0xd4, 0xb8, 0x93,
	0xed, 0x6c, 0x37, 0xdb, 0x1b, 0x4d, 0xc6, 0xf2, 0xca, 0xd5, 0xf2, 0x5d, 0xc2, 0x86, 0x4b, 0x6f,
	0xef, 0x14, 0x17, 0x4b, 0xf9, 0x1b, 0xb1, 0x4a, 0x0d, 0x27, 0x81, 0xbb, 0x51, 0xe0, 0xf9, 0x40,
	0xe0, 0x63, 0x0f, 0x5e, 0x53, 0xb8, 0x5c, 0x3b, 0x5a, 0x15, 0x2b, 0xa9, 0x8b, 0xf1, 0xbf, 0x4c,
	0x6c, 0xdd, 0xe8, 0x98, 0xff, 0x12, 0x23, 0xdd, 0xf0, 0x69, 0xdf, 0x6f, 0x7f, 0xea, 0x77, 0x19,
	0x9b, 0x94, 0x7d, 0xe9, 0xa9, 0x49, 0xd9, 0x37, 0x29, 0x6f, 0xe9, 0xa9, 0x9d, 0xc8, 0x69, 0x64,
	0x4c, 0x97, 0x84, 0x62, 0x89, 0x17, 0xa2, 0xf3, 0xeb, 0xdd, 0xa5, 0xd8, 0xb0, 0x64, 0xb4, 0x2d,
	0x1b, 0x5f, 0x73, 0x00, 0xbd, 0x28, 0x9d, 0x5e, 0x40, 0xcc, 0xbb, 0x56, 0x3c, 0x8e, 0xd0, 0x97,
	0x1e, 0xf9, 0xa0, 0x17, 0x90, 0xbf, 0x10, 0x79, 0xe2, 0xd7, 0x10, 0x5a, 0x34, 0x50, 0x7a, 0x0a,
	0xbc, 0x7d, 0x6f, 0x37, 0xdb, 0x7b, 0x58, 0x3c, 0x8a, 0xc8, 0xa7, 0x04, 0x1c, 0x53, 0xe0, 0xf1,
	0x57, 0xf1, 0xe4, 0xe6, 0x96, 0xf2, 0x43, 0xf1, 0xc0, 0x07, 0xfa, 0x79, 0x3e, 0x8c, 0xfd, 0x74,
	0x50, 0xf0, 0x67, 0xe3, 0x8f, 0x3b, 0x4e, 0x5a, 0x29, 0x46, 0x7e, 0xf9, 0x31, 0x9e, 0x8a, 0xf5,
	0x21, 0x9c, 0x1f, 0x88, 0xcd, 0x13, 0xa8, 0x19, 0x9d, 0xee, 0x42, 0x5e, 0xe6, 0x89, 0xca, 0x6b,
	0xc5, 0xc6, 0x15, 0xec, 0x22, 0xd0, 0xd1, 0xeb, 0x3f, 0x7f, 0x9f, 0x65, 0xdf, 0x5e, 0x55, 0xc8,
	0xa7, 0xcd, 0x4c, 0x1a, 0x5a, 0xa8, 0x9a, 0x2c, 0xed, 0x23, 0xa9, 0xee, 0x8c, 0x7d, 0x70, 0x0c,
	0xc1, 0x07, 0xac, 0x41, 0xf9, 0xb3, 0x4a, 0x79, 0xdb, 0x54, 0xe8, 0xea, 0xee, 0x75, 0x3b, 0x30,
	0x3c, 0x5b, 0x89, 0x2f, 0xef, 0xe5, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf4, 0x85, 0xfb, 0xe0,
	0x23, 0x03, 0x00, 0x00,
}
